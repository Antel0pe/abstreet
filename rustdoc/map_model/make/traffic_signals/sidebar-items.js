initSidebarItems({"constant":[["PROTECTED",""],["YIELD",""]],"fn":[["all_walk_all_yield",""],["brute_force","Temporary experiment to group all movements into the smallest number of stages."],["degenerate",""],["expand_all_stages",""],["four_way_four_stage",""],["four_way_two_stage",""],["get_possible_policies","Applies a bunch of heuristics to a single intersection, returning the valid results in best-first order. The signal configuration is only based on the roads connected to the intersection."],["get_sorted_incoming_roads","Return all incoming roads to an intersection, sorted by angle. This skips one-way roads outbound from the intersection, since no turns originate from those anyway. This allows heuristics for a 3-way intersection to not care if one of the roads happens to be a dual carriageway (split into two one-ways)."],["greedy_assignment",""],["half_signal",""],["helper",""],["lagging_green","Create a traffic signal which has a stage that is: protected straight, protected right, unprotected left, unprotected right on red. Followed by a variable stage that has protected left, unprotected right on red. With a last stage that is all-walk and variable. In some degenerate cases, usually with one or more one-way, this can reduce to stage per road. In some rare cases, usually with an alleyway, oncoming lanes can't both be protected left turns. In such cases the stage is split into two stages with each having a protected and yeild turn."],["make_stages",""],["make_stages_filtered",""],["new",""],["okay_partition",""],["stage_per_road",""],["synchronize","Simple second-pass after generating all signals. Find pairs of traffic signals very close to each other with 2 stages each, see if the primary movement of the first stages lead to each other, and flip the order of stages if not. This is often wrong when the most common movement is actually turning left then going straight (near Mercer for example), but not sure how we could know that without demand data."],["three_way",""]],"struct":[["Partition",""]]});